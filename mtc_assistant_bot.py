# -*- coding: utf-8 -*-
"""
MTC Assistant v14 - Song Searching Feature + YouTube validation
"""

# --- 1. Imports ---
import os
import datetime
import logging
import re
import json
from typing import Optional
from zoneinfo import ZoneInfo

import requests
from flask import Flask, request, abort

import google.generativeai as genai
from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.messaging import (
    Configuration, ApiClient, MessagingApi, ReplyMessageRequest, TextMessage, ImageMessage
)
from linebot.v3.webhooks import MessageEvent, TextMessageContent, FollowEvent

# ==========================================================================================
# --- 2. Configuration & Constants ---
# ==========================================================================================
app = Flask(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Credentials (from environment) ---
ACCESS_TOKEN = os.environ.get('CHANNEL_ACCESS_TOKEN')
CHANNEL_SECRET = os.environ.get('CHANNEL_SECRET')
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
YOUTUBE_API_KEY = os.environ.get('YOUTUBE_API_KEY')  # Optional but highly recommended

if not ACCESS_TOKEN:
    app.logger.warning("CHANNEL_ACCESS_TOKEN is not set. LINE API calls will fail.")
if not CHANNEL_SECRET:
    app.logger.warning("CHANNEL_SECRET is not set. Signature verification will fail.")
if not GEMINI_API_KEY:
    app.logger.info("GEMINI_API_KEY is not set. AI features will be disabled.")
if not YOUTUBE_API_KEY:
    app.logger.info("YOUTUBE_API_KEY is not set. YouTube validation will use fallback (less reliable).")

# --- Bot Constants & Links ---
WORKSHEET_LINK = "https://docs.google.com/spreadsheets/d/1oCG--zkyp-iyJ8iFKaaTrDZji_sds2VzLWNxOOh7-xk/edit?usp=sharing"
SCHOOL_LINK = "https://www.ben.ac.th/main/"
TIMETABLE_IMG = "https://img5.pic.in.th/file/secure-sv1/-2395abd52df9b5e08.jpg"
GRADE_LINK = "http://www.dograde2.online/bjrb/"
ABSENCE_LINK = "https://forms.gle/WjCBTYNxEeCpHShr9"
Bio_LINK = "https://drive.google.com/file/d/1zd5NND3612JOym6HSzKZnqAS42TH9gmh/view?usp=sharing"

EXAM_DATES = {
    "‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ": datetime.date(2025, 12, 20),
    "‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ": datetime.date(2026, 2, 20)
}

LINE_MAX_TEXT = 5000
LINE_SAFE_TRUNCATE = 4800
LOCAL_TZ = ZoneInfo("Asia/Bangkok")

# --- Class schedule omitted for brevity (same as before) ---
SCHEDULE = {
    0: [
        {"start": "08:30", "end": "09:25", "subject": "‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå (‡∏Ñ‡∏£‡∏π‡∏ò‡∏ô‡∏ò‡∏±‡∏ç)", "room": "331"},
        {"start": "09:25", "end": "10:20", "subject": "‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå (‡∏Ñ‡∏£‡∏π‡∏ò‡∏ô‡∏ò‡∏±‡∏ç)", "room": "331"},
        {"start": "10:20", "end": "11:15", "subject": "‡πÄ‡∏Ñ‡∏°‡∏µ (‡∏Ñ‡∏£‡∏π‡∏û‡∏¥‡∏ó‡∏¢‡∏≤‡∏†‡∏£‡∏ì‡πå)", "room": "311"},
        {"start": "11:15", "end": "12:10", "subject": "‡πÅ‡∏ô‡∏∞‡πÅ‡∏ô‡∏ß (‡∏Ñ‡∏£‡∏π‡∏ó‡∏®‡∏û‡∏£)", "room": "947"},
        {"start": "13:05", "end": "14:00", "subject": "‡∏ô‡∏≤‡∏è‡∏®‡∏¥‡∏•‡∏õ‡πå (‡∏Ñ‡∏£‡∏π‡∏ö‡∏±‡∏á‡πÄ‡∏≠‡∏¥‡∏ç)", "room": "575"},
        {"start": "14:00", "end": "14:55", "subject": "‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô‡∏≠‡∏≤‡∏ä‡∏µ‡∏û (‡∏Ñ‡∏£‡∏π‡∏≠‡∏±‡∏ç‡∏ä‡∏•‡∏µ)", "room": "947"},
        {"start": "14:55", "end": "15:50", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡∏Ñ‡∏£‡∏π‡∏°‡∏≤‡∏ô‡∏û)", "room": "947"},
        {"start": "15:50", "end": "16:45", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡∏Ñ‡∏£‡∏π‡∏°‡∏≤‡∏ô‡∏û)", "room": "947"},
    ],
    1: [
        {"start": "08:30", "end": "09:25", "subject": "‡πÄ‡∏Ñ‡∏°‡∏µ (‡∏Ñ‡∏£‡∏π‡∏û‡∏¥‡∏ó‡∏¢‡∏≤‡∏†‡∏£‡∏ì‡πå)", "room": "311"},
        {"start": "09:25", "end": "10:20", "subject": "‡πÄ‡∏Ñ‡∏°‡∏µ (‡∏Ñ‡∏£‡∏π‡∏û‡∏¥‡∏ó‡∏¢‡∏≤‡∏†‡∏£‡∏ì‡πå)", "room": "311"},
        {"start": "10:20", "end": "11:15", "subject": "‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå (‡∏Ñ‡∏£‡∏π‡∏ò‡∏ô‡∏ò‡∏±‡∏ç)", "room": "333"},
        {"start": "11:15", "end": "12:10", "subject": "‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå (‡∏Ñ‡∏£‡∏π‡∏ò‡∏ô‡∏ò‡∏±‡∏ç)", "room": "333"},
        {"start": "13:05", "end": "14:00", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏π‡∏ô (‡∏Ñ‡∏£‡∏π‡∏°‡∏≤‡∏ô‡∏û)", "room": "947"},
        {"start": "14:00", "end": "14:55", "subject": "‡∏™‡∏±‡∏á‡∏Ñ‡∏°‡∏®‡∏∂‡∏Å‡∏©‡∏≤ (‡∏Ñ‡∏£‡∏π‡∏ö‡∏±‡∏á‡∏≠‡∏£)", "room": "947"},
        {"start": "14:55", "end": "15:50", "subject": "‡πÑ‡∏ó‡∏¢ (‡∏Ñ‡∏£‡∏π‡πÄ‡∏ö‡∏ç‡∏à‡∏°‡∏≤‡∏®)", "room": "947"},
        {"start": "15:50", "end": "16:45", "subject": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏Ñ‡∏£‡∏π‡∏ß‡∏≤‡∏™‡∏ô‡∏≤)", "room": "947"},
    ],
    2: [
        {"start": "08:30", "end": "09:25", "subject": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏Ñ‡∏£‡∏π‡∏ß‡∏≤‡∏™‡∏ô‡∏≤)", "room": "947"},
        {"start": "09:25", "end": "10:20", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏π‡∏ô (‡∏Ñ‡∏£‡∏π‡∏°‡∏≤‡∏ô‡∏û)", "room": "947"},
        {"start": "10:20", "end": "11:15", "subject": "‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå (‡∏Ñ‡∏£‡∏π‡∏ì‡∏ê‡∏û‡∏£)", "room": "947"},
        {"start": "11:15", "end": "12:10", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏Ñ‡∏£‡∏π‡∏õ‡∏£‡∏µ‡∏¢‡∏≤)", "room": "947"},
    ],
    3: [
        {"start": "08:30", "end": "09:25", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏π‡∏ô (‡∏Ñ‡∏£‡∏π‡∏°‡∏≤‡∏ô‡∏û)", "room": "947"},
        {"start": "09:25", "end": "10:20", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏π‡∏ô (‡∏Ñ‡∏£‡∏π‡∏°‡∏≤‡∏ô‡∏û)", "room": "947"},
        {"start": "10:20", "end": "11:15", "subject": "‡∏ä‡∏µ‡∏ß‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (‡∏Ñ‡∏£‡∏π‡∏û‡∏¥‡∏ä‡∏≤‡∏°‡∏ç‡∏ä‡πå)", "room": "323"},
        {"start": "11:15", "end": "12:10", "subject": "‡πÑ‡∏ó‡∏¢ (‡∏Ñ‡∏£‡∏π‡πÄ‡∏ö‡∏ç‡∏à‡∏°‡∏≤‡∏®)", "room": "947"},
        {"start": "13:05", "end": "14:00", "subject": "‡∏™‡∏∏‡∏Ç‡∏®‡∏∂‡∏Å‡∏©‡∏≤&‡∏û‡∏•‡∏∞‡∏®‡∏∂‡∏Å‡∏©‡∏≤ (‡∏Ñ‡∏£‡∏π‡∏ô‡∏£‡πÄ‡∏®‡∏£‡∏©‡∏ê‡πå)", "room": "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô/‡πÇ‡∏î‡∏°"},
        {"start": "14:00", "end": "14:55", "subject": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (Teacher Mitch)", "room": "947"},
        {"start": "14:55", "end": "15:50", "subject": "‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏Ñ‡∏£‡∏π‡∏õ‡∏£‡∏µ‡∏¢‡∏≤)", "room": "947"},
    ],
    4: [
        {"start": "08:30", "end": "09:25", "subject": "‡∏ä‡∏µ‡∏ß‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (‡∏Ñ‡∏£‡∏π‡∏û‡∏¥‡∏ä‡∏≤‡∏°‡∏ç‡∏ä‡πå)", "room": "323"},
        {"start": "09:25", "end": "10:20", "subject": "‡∏ä‡∏µ‡∏ß‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤ (‡∏Ñ‡∏£‡∏π‡∏û‡∏¥‡∏ä‡∏≤‡∏°‡∏ç‡∏ä‡πå)", "room": "323"},
        {"start": "10:20", "end": "11:15", "subject": "‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (‡∏Ñ‡∏£‡∏π‡∏ß‡∏≤‡∏™‡∏ô‡∏≤)", "room": "947"},
        {"start": "11:15", "end": "12:10", "subject": "‡∏™‡∏±‡∏á‡∏Ñ‡∏°‡∏®‡∏∂‡∏Å‡∏©‡∏≤ (‡∏Ñ‡∏£‡∏π‡∏ö‡∏±‡∏á‡∏≠‡∏£)", "room": "947"},
        {"start": "13:05", "end": "14:00", "subject": "‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå (‡∏Ñ‡∏£‡∏π‡∏à‡∏¥‡∏ô‡∏î‡∏≤‡∏û‡∏£)", "room": "221"},
        {"start": "14:00", "end": "14:55", "subject": "‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå (‡∏Ñ‡∏£‡∏π‡∏à‡∏¥‡∏ô‡∏î‡∏≤‡∏û‡∏£)", "room": "221"},
        {"start": "14:55", "end": "15:50", "subject": "IS (‡∏Ñ‡∏£‡∏π‡∏õ‡∏£‡∏µ‡∏¢‡∏≤)", "room": "947"},
        {"start": "15:50", "end": "16:45", "subject": "IS (‡∏Ñ‡∏£‡∏π‡∏õ‡∏£‡∏µ‡∏¢‡∏≤)", "room": "947"},
    ]
}

# ==========================================================================================
# --- 3. Initialize APIs ---
# ==========================================================================================
configuration = Configuration(access_token=ACCESS_TOKEN)
handler = WebhookHandler(CHANNEL_SECRET)
gemini_model = None
GEMINI_MODEL_NAME = "gemini-2.5-flash"

try:
    if GEMINI_API_KEY:
        genai.configure(api_key=GEMINI_API_KEY)
        try:
            gemini_model = getattr(genai, "GenerativeModel")(GEMINI_MODEL_NAME)
            app.logger.info("Gemini model instantiated via GenerativeModel.")
        except Exception:
            gemini_model = None
            app.logger.info("Gemini API configured, will use function-level calls as fallback.")
    else:
        app.logger.warning("GEMINI_API_KEY is not set. AI features will be disabled.")
except Exception as e:
    app.logger.error(f"Error configuring Gemini AI: {e}", exc_info=True)
    gemini_model = None

# ==========================================================================================
# --- 4. Core Helper Functions ---
# ==========================================================================================

def get_next_class_info() -> str:
    now = datetime.datetime.now(tz=LOCAL_TZ)
    weekday = now.weekday()
    current_time = now.time()

    if weekday not in SCHEDULE:
        return "‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏ß‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ß‡∏±‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ô ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ô‡∏≠‡∏ô‡πÑ‡∏õ‡πä üéâ"

    for period in SCHEDULE[weekday]:
        start_time = datetime.datetime.strptime(period["start"], "%H:%M").time()
        if current_time < start_time:
            return (f"‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÑ‡∏õ ‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ‡∏Ñ‡∏£‡∏±‡∏ö\n"
                    f"‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡∏≤‡∏ö : {period['start']}\n"
                    f"‡∏à‡∏ö‡∏Ñ‡∏≤‡∏ö : {period['end']}\n"
                    f"‡∏ß‡∏¥‡∏ä‡∏≤ : {period['subject']}\n"
                    f"‡∏´‡πâ‡∏≠‡∏á : {period['room']}")
    return "‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≤‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Å‡∏•‡∏±‡∏ö‡∏ö‡πâ‡∏≤‡∏ô‡πÑ‡∏õ‡∏ô‡∏≠‡∏ô‡πÑ‡∏î‡πâ üè†"

def create_countdown_message(exam_name: str, exam_date: datetime.date) -> str:
    today = datetime.datetime.now(tz=LOCAL_TZ).date()
    delta = exam_date - today
    days_left = delta.days

    if days_left > 0:
        return f"‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏µ‡∏Å {days_left} ‡∏ß‡∏±‡∏ô‡∏à‡∏∞‡∏ñ‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏™‡∏≠‡∏ö{exam_name} ({exam_date.strftime('%d %b %Y')})"
    elif days_left == 0:
        return f"‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏ß‡∏±‡∏ô‡∏™‡∏≠‡∏ö{exam_name}‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏ä‡∏Ñ‡∏î‡∏µ‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö :)"
    else:
        return f"‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ö{exam_name}‡πÑ‡∏î‡πâ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö"

def _safe_parse_gemini_response(response) -> str:
    try:
        if response is None:
            return ""
        if hasattr(response, "text"):
            return str(response.text).strip()
        if isinstance(response, dict):
            if "text" in response and response["text"]:
                return str(response["text"]).strip()
            if "candidates" in response and response["candidates"]:
                first = response["candidates"][0]
                if isinstance(first, dict) and "content" in first:
                    return str(first["content"]).strip()
                return str(first).strip()
        if hasattr(response, "result"):
            return str(getattr(response, "result")).strip()
        if hasattr(response, "candidates"):
            c = getattr(response, "candidates")
            if c:
                first = c[0]
                if hasattr(first, "content"):
                    return str(getattr(first, "content")).strip()
                return str(first).strip()
        return str(response).strip()
    except Exception as e:
        app.logger.debug(f"Error parsing Gemini response: {e}", exc_info=True)
        return str(response)

def get_gemini_response(user_message: str) -> str:
    identity_msg = (
        "‡∏ú‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏≠‡∏ó‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡πÄ‡∏ô‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå‡∏Ç‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á MTC ‡∏°.4/2 "
        "‡∏ú‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡πÄ‡∏ä‡πà‡∏ô ‡πÅ‡∏à‡πâ‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á, ‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô, ‡∏´‡∏≤‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô, ‡πÅ‡∏•‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢ AI"
    )

    identity_queries = ["‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡πÉ‡∏Ñ‡∏£", "‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏Ñ‡∏£", "who are you", "‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏∞‡πÑ‡∏£", "‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏∞‡πÑ‡∏£", "‡∏ï‡∏±‡∏ß‡∏ï‡∏ô"]
    lowered = user_message.lower()
    if any(q in lowered for q in identity_queries):
        return identity_msg

    if not GEMINI_API_KEY:
        return "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö AI ‡∏Ç‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå"

    try:
        response = None
        if gemini_model is not None:
            if hasattr(gemini_model, "generate_content"):
                response = gemini_model.generate_content(user_message)
            elif hasattr(gemini_model, "generate"):
                response = gemini_model.generate(user_message)
            else:
                response = None

        if response is None:
            try:
                if hasattr(genai, "generate_text"):
                    response = genai.generate_text(model=GEMINI_MODEL_NAME, input=user_message)
                elif hasattr(genai, "chat"):
                    chat_create = getattr(genai, "chat").create if hasattr(genai.chat, "create") else getattr(genai.chat, "generate", None)
                    if chat_create:
                        response = chat_create(model=GEMINI_MODEL_NAME, messages=[{"role": "user", "content": user_message}])
                    else:
                        response = None
                else:
                    if hasattr(genai, "generate"):
                        response = genai.generate(model=GEMINI_MODEL_NAME, prompt=user_message)
                    else:
                        response = None
            except Exception as e:
                app.logger.debug(f"Gemini module-level call failed: {e}", exc_info=True)
                response = None

        reply_text = _safe_parse_gemini_response(response)
        if not reply_text:
            return "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö AI ‡∏ï‡∏≠‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"

        reply_text = re.sub(r'\b[Gg]oogle\b', 'Gemini', reply_text)
        reply_text = reply_text.replace('‡∏Å‡∏π‡πÄ‡∏Å‡∏¥‡∏•', 'Gemini')

        if re.search(r'(‡πÅ‡∏ö‡∏ö‡∏à‡∏≥‡∏•‡∏≠‡∏á|‡∏ù‡∏∂‡∏Å‡πÇ‡∏î‡∏¢|‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°|trained by|model)', reply_text, flags=re.IGNORECASE):
            lines = reply_text.splitlines()
            filtered_lines = [ln for ln in lines if not re.search(r'(‡πÅ‡∏ö‡∏ö‡∏à‡∏≥‡∏•‡∏≠‡∏á|‡∏ù‡∏∂‡∏Å‡πÇ‡∏î‡∏¢|‡∏ù‡∏∂‡∏Å‡∏≠‡∏ö‡∏£‡∏°|trained by|model)', ln, flags=re.IGNORECASE)]
            remaining = "\n".join(filtered_lines).strip()
            reply_text = identity_msg
            if remaining:
                reply_text = reply_text + "\n\n" + remaining

        if len(reply_text) > LINE_SAFE_TRUNCATE:
            reply_text = reply_text[:LINE_SAFE_TRUNCATE] + "... (‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏±‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô 5,000 ‡∏Ñ‡∏≥‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)"

        return reply_text
    except Exception as e:
        app.logger.error(f"Gemini API Error: {e}", exc_info=True)
        return "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏ú‡∏°‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö AI ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞"

def reply_to_line(reply_token: str, messages: list):
    if not messages:
        app.logger.warning("reply_to_line called with no messages.")
        return
    try:
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            line_bot_api.reply_message(
                ReplyMessageRequest(reply_token=reply_token, messages=messages)
            )
    except Exception as e:
        app.logger.error(f"Error sending reply to LINE: {e}", exc_info=True)

# ==========================================================================================
# --- 5. Command-Specific Action Functions ---
# ==========================================================================================
def get_worksheet_message():
    return TextMessage(text=f'‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏ä‡πá‡∏Ñ‡∏á‡∏≤‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö\n{WORKSHEET_LINK}')

def get_school_link_message():
    return TextMessage(text=f'‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö\n{SCHOOL_LINK}')

def get_timetable_image_message():
    return ImageMessage(original_content_url=TIMETABLE_IMG, preview_image_url=TIMETABLE_IMG)

def get_grade_link_message():
    return TextMessage(text=f'‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÄ‡∏ß‡πá‡∏ö‡∏î‡∏π‡πÄ‡∏Å‡∏£‡∏î‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö\n{GRADE_LINK}')

def get_next_class_message():
    return TextMessage(text=get_next_class_info())

def get_absence_form_message():
    return TextMessage(text=f'‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÅ‡∏ö‡∏ö‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏•‡∏≤‡∏Å‡∏¥‡∏à-‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö\n{ABSENCE_LINK}')

def get_bio_link_message():
    return TextMessage(text=f'‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏â‡∏•‡∏¢‡∏ä‡∏µ‡∏ß‡∏∞ ‡∏ö‡∏ó‡∏ó‡∏µ‡πà 4-7 ‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö\n{Bio_LINK}')

def get_help_message():
    help_text = (
        '‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n'
        '- "‡∏á‡∏≤‡∏ô" = ‡∏î‡∏π‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏≤‡∏ô (worksheet)\n'
        '- "‡πÄ‡∏ß‡πá‡∏ö" = ‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô\n'
        '- "‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô" = ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô‡πÄ‡∏ó‡∏≠‡∏° 2 ‡∏´‡πâ‡∏≠‡∏á 4/2\n'
        '- "‡πÄ‡∏Å‡∏£‡∏î" = ‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏Å‡∏£‡∏î\n'
        '- "‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÑ‡∏õ/‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÑ‡∏£‡∏ï‡πà‡∏≠" = ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡∏≤‡∏ö‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå\n'
        '- "‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢/‡∏•‡∏≤‡∏Å‡∏¥‡∏à/‡∏•‡∏≤" = ‡πÅ‡∏ö‡∏ö‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏•‡∏≤‡∏Å‡∏¥‡∏à-‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢\n'
        '- "‡∏™‡∏≠‡∏ö" = ‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏ß‡∏±‡∏ô‡∏™‡∏≠‡∏ö\n'
        '- "‡∏ä‡∏µ‡∏ß‡∏∞" = ‡πÄ‡∏â‡∏•‡∏¢‡∏ä‡∏µ‡∏ß‡∏∞\n'
        '- "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏•‡∏á [‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á]" = ‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á‡∏à‡∏≤‡∏Å Youtube\n'
        '- ‡∏ñ‡πâ‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏∑‡πà‡∏ô ‡πÜ ‡∏ú‡∏°‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏≠‡πÑ‡∏≠'
    )
    return TextMessage(text=help_text)

# --- YouTube helpers (validation + search) ---
def extract_youtube_id(url_or_text: str) -> Optional[str]:
    if not url_or_text:
        return None
    # Look for common URL patterns; YouTube video IDs are typically 11 chars
    m = re.search(r'(?:v=|\/v\/|youtu\.be\/|\/embed\/)([A-Za-z0-9_\-]{11})', url_or_text)
    if m:
        return m.group(1)
    # If the user provided just an ID
    m2 = re.match(r'^[A-Za-z0-9_\-]{11}$', url_or_text.strip())
    if m2:
        return url_or_text.strip()
    return None

def youtube_check_video_status(video_id: str, region_code: str = "TH") -> dict:
    if not video_id:
        return {"ok": False, "reason": "no_video_id", "info": None}

    if YOUTUBE_API_KEY:
        params = {"part": "status,contentDetails", "id": video_id, "key": YOUTUBE_API_KEY}
        try:
            r = requests.get("https://www.googleapis.com/youtube/v3/videos", params=params, timeout=6)
        except Exception as e:
            return {"ok": False, "reason": f"yt_api_request_failed_{e}", "info": None}
        if r.status_code != 200:
            return {"ok": False, "reason": f"yt_api_error_{r.status_code}", "info": r.text}
        data = r.json()
        items = data.get("items", [])
        if not items:
            return {"ok": False, "reason": "not_found", "info": data}
        item = items[0]
        status = item.get("status", {})
        content = item.get("contentDetails", {})

        if status.get("privacyStatus") != "public":
            return {"ok": False, "reason": f"privacy_{status.get('privacyStatus')}", "info": item}
        if status.get("uploadStatus") and status.get("uploadStatus") != "processed":
            return {"ok": False, "reason": f"upload_{status.get('uploadStatus')}", "info": item}
        region = content.get("regionRestriction", {})
        blocked = region.get("blocked")
        allowed = region.get("allowed")
        if blocked and region_code and region_code in blocked:
            return {"ok": False, "reason": f"region_blocked_{region_code}", "info": item}
        return {"ok": True, "reason": "ok", "info": item}

    # Fallback: oEmbed check or page text scan
    try:
        oembed_url = f"https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v={video_id}&format=json"
        r2 = requests.get(oembed_url, timeout=6)
        if r2.status_code == 200:
            return {"ok": True, "reason": "ok_oembed", "info": r2.json()}
        else:
            watch = requests.get(f"https://www.youtube.com/watch?v={video_id}", timeout=6)
            txt = watch.text.lower()
            if "video unavailable" in txt or "‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô" in txt or "this video is unavailable" in txt:
                return {"ok": False, "reason": "page_unavailable", "info": {"status_code": watch.status_code}}
            return {"ok": True, "reason": "assume_ok", "info": {"status_code": watch.status_code}}
    except Exception as e:
        return {"ok": False, "reason": f"fallback_error_{e}", "info": None}

def youtube_search_videos(query: str, max_results: int = 5) -> list:
    if not query:
        return []
    if not YOUTUBE_API_KEY:
        return []
    params = {
        "part": "snippet",
        "q": query,
        "type": "video",
        "maxResults": max_results,
        "key": YOUTUBE_API_KEY,
        "regionCode": "TH"
    }
    try:
        r = requests.get("https://www.googleapis.com/youtube/v3/search", params=params, timeout=6)
    except Exception:
        return []
    if r.status_code != 200:
        return []
    resp = r.json()
    items = resp.get("items", [])
    ids = []
    for it in items:
        vid = it.get("id", {}).get("videoId")
        if vid:
            ids.append(vid)
    return ids

# --- Modified music function with validation ---
def get_music_link_message(user_message: str):
    app.logger.info(f"Handling music request: {user_message}")
    music_keywords = ["‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏•‡∏á", "‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á", "‡∏Ç‡∏≠‡πÄ‡∏û‡∏•‡∏á"]
    song_title = user_message
    for keyword in music_keywords:
        if song_title.startswith(keyword):
            song_title = song_title[len(keyword):].strip()
            break
    if not song_title:
        return TextMessage(text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡πÄ‡∏ä‡πà‡∏ô '‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏•‡∏á [‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á]'")

    search_prompt = (
        f"‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏•‡∏¥‡∏á‡∏Å‡πå YouTube ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£ (Official) ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏î‡∏µ "
        f"‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏•‡∏á‡∏ô‡∏µ‡πâ: '{song_title}' ‡πÅ‡∏•‡∏∞‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏•‡∏¥‡∏á‡∏Å‡πå YouTube ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏ñ‡πâ‡∏≤‡∏´‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏ß‡πà‡∏≤ '‡∏´‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠'"
    )
    ai_response = get_gemini_response(search_prompt)

    url_match = re.search(r'(https?://(?:www\.)?(?:youtube\.com|youtu\.be)[^\s\'"]+)', ai_response or "")
    if url_match:
        candidate_url = url_match.group(0).strip(")'\"")
        vid = extract_youtube_id(candidate_url)
        if vid:
            status = youtube_check_video_status(vid)
            if status.get("ok"):
                return TextMessage(text=f"‡∏à‡∏±‡∏î‡πÑ‡∏õ‡∏Ñ‡∏£‡∏±‡∏ö! üéµ\nhttps://www.youtube.com/watch?v={vid}")
            else:
                app.logger.info(f"Found video but not playable: {status}")
                if YOUTUBE_API_KEY:
                    alt_ids = youtube_search_videos(song_title, max_results=5)
                    for alt in alt_ids:
                        st = youtube_check_video_status(alt)
                        if st.get("ok"):
                            return TextMessage(text=f"‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡∏ú‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏∑‡πà‡∏ô‡∏°‡∏≤‡πÉ‡∏´‡πâ‡πÅ‡∏ó‡∏ô üéµ\nhttps://www.youtube.com/watch?v={alt}")
                return TextMessage(text="‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö ‡∏•‡∏≠‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏®‡∏¥‡∏•‡∏õ‡∏¥‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏° (‡πÄ‡∏ä‡πà‡∏ô '‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏•‡∏á Just the two of us - Bill Withers')")

    if "‡∏´‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠" in (ai_response or "").lower() or not url_match:
        if YOUTUBE_API_KEY:
            candidates = youtube_search_videos(song_title, max_results=5)
            for c in candidates:
                st = youtube_check_video_status(c)
                if st.get("ok"):
                    return TextMessage(text=f"‡∏ú‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô‡πÄ‡∏à‡∏≠‡∏Ñ‡∏£‡∏±‡∏ö üéµ\nhttps://www.youtube.com/watch?v={c}")
            return TextMessage(text="‡∏ú‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡∏π‡∏Å‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡∏•‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏®‡∏¥‡∏•‡∏õ‡∏¥‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏´‡πâ‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö")
        else:
            return TextMessage(text=f"{ai_response}\n(‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏´‡∏≤‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏ö‡∏≠‡∏ó‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ YOUTUBE_API_KEY ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥)")

    return TextMessage(text=f"‡∏ú‡∏°‡∏´‡∏≤‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏±‡∏ö ‡πÅ‡∏ï‡πà‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏°‡∏≤‡∏ß‡πà‡∏≤:\n{ai_response}")

def get_exam_countdown_message(user_message: str):
    if "‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ" in user_message:
        reply_text = create_countdown_message("‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ", EXAM_DATES["‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ"])
    elif "‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ" in user_message:
        reply_text = create_countdown_message("‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ", EXAM_DATES["‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ"])
    else:
        midterm = create_countdown_message("‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ", EXAM_DATES["‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ"]) if "‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ" in EXAM_DATES else ""
        final = create_countdown_message("‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ", EXAM_DATES["‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ"]) if "‡∏õ‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏Ñ" in EXAM_DATES else ""
        if midterm and final:
            reply_text = f"{midterm}\n\n{final}"
        else:
            reply_text = midterm or final or "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏±‡∏ô‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏£‡∏±‡∏ö"
    return TextMessage(text=reply_text)

# ==========================================================================================
# --- 6. LINE Bot Event Handlers & Command Matching ---
# ==========================================================================================
@handler.add(FollowEvent)
def handle_follow(event):
    welcome_message = TextMessage(
        text='‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏±‡∏ö! ‡∏ú‡∏°‡∏Ñ‡∏∑‡∏≠ MTC Assistant ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡πÄ‡∏ô‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå‡∏Ç‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á ‡∏°.4/2\n'
             '‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏•‡∏≠‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡∏Ñ‡∏∏‡∏¢‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡∏ú‡∏°‡∏Å‡πá‡πÑ‡∏î‡πâ‡∏ô‡∏∞!\n\n'
             '‡∏û‡∏¥‡∏°‡∏û‡πå "‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö'
    )
    reply_to_line(event.reply_token, [welcome_message])

COMMANDS = [
    (("‡∏á‡∏≤‡∏ô", "‡∏Å‡∏≤‡∏£‡∏ö‡πâ‡∏≤‡∏ô", "‡πÄ‡∏ä‡πá‡∏Ñ‡∏á‡∏≤‡∏ô"), get_worksheet_message),
    (("‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡πÄ‡∏ß‡πá‡∏ö"), get_school_link_message),
    (("‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏™‡∏≠‡∏ô"), get_timetable_image_message),
    (("‡πÄ‡∏Å‡∏£‡∏î", "‡∏î‡∏π‡πÄ‡∏Å‡∏£‡∏î"), get_grade_link_message),
    (("‡∏Ñ‡∏≤‡∏ö‡∏ï‡πà‡∏≠‡πÑ‡∏õ", "‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏∞‡πÑ‡∏£", "‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÑ‡∏£‡∏ï‡πà‡∏≠"), get_next_class_message),
    (("‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢", "‡∏•‡∏≤‡∏Å‡∏¥‡∏à", "‡∏•‡∏≤"), get_absence_form_message),
    (("‡∏ä‡∏µ‡∏ß‡∏∞", "‡πÄ‡∏â‡∏•‡∏¢‡∏ä‡∏µ‡∏ß‡∏∞"), get_bio_link_message),
    (("‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏û‡∏•‡∏á", "‡∏´‡∏≤‡πÄ‡∏û‡∏•‡∏á", "‡∏Ç‡∏≠‡πÄ‡∏û‡∏•‡∏á"), lambda msg: get_music_link_message(msg)),
    (("‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á", "help", "‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠"), get_help_message),
    (("‡∏™‡∏≠‡∏ö",), lambda msg: get_exam_countdown_message(msg)),
]

def _keyword_matches(user_message: str, keyword: str) -> bool:
    try:
        kw = keyword.lower()
        um = user_message.lower()
        # Ensure keyword is not adjacent to ASCII word chars or Thai chars (Unicode range \u0E00-\u0E7F)
        pattern = rf'(?<![\w\u0E00-\u0E7F]){re.escape(kw)}(?![\w\u0E00-\u0E7F])'
        return bool(re.search(pattern, um, flags=re.IGNORECASE))
    except re.error:
        return keyword in user_message

def call_action(action, user_message: str):
    try:
        return action(user_message)
    except TypeError:
        try:
            return action()
        except TypeError:
            return action(user_message)

@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    user_text = getattr(event.message, "text", "")
    user_message = user_text.lower().strip()
    reply_message = None

    # Rule-based commands (check longer keywords first to avoid short accidental matches)
    for keywords, action in COMMANDS:
        matched = False
        for keyword in sorted(keywords, key=len, reverse=True):
            if _keyword_matches(user_message, keyword):
                try:
                    reply_message = call_action(action, user_message)
                except Exception as e:
                    app.logger.error(f"Error calling action for keywords {keywords}: {e}", exc_info=True)
                    reply_message = TextMessage(text="‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì")
                matched = True
                break
        if matched:
            break

    # AI fallback
    if not reply_message:
        ai_response_text = get_gemini_response(user_message)
        reply_message = TextMessage(text=ai_response_text)

    if reply_message:
        reply_to_line(event.reply_token, [reply_message])
    else:
        app.logger.warning(f"No reply was generated for message: {user_message}")

# ==========================================================================================
# --- 7. Flask Web Server ---
# ==========================================================================================
@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers.get('X-Line-Signature')
    if not signature:
        app.logger.error("Missing X-Line-Signature header.")
        abort(400)
    body = request.get_data(as_text=True)
    app.logger.info(f"Request body: {body}")
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature. Please check your channel secret.")
        abort(400)
    except Exception as e:
        app.logger.error(f"Error handling request: {e}", exc_info=True)
        abort(500)
    return 'OK'

@app.route("/", methods=['GET'])
def home():
    cfg_ok = "OK" if ACCESS_TOKEN and CHANNEL_SECRET else "CONFIG_MISSING"
    return f"MTC Assistant is running! ({cfg_ok})"

if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5001))
    app.run(host='0.0.0.0', port=port)
